<html>
<head>
<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@100&display=swap" rel="stylesheet">
<title>
    GoodTime Web
</title>
<style type="text/css">
  @font-face {
    font-family: TimerFont;
    src:url("/RobotoMono-Thin.ttf");
  }

  body, html {
    height: 100%;
    width: 100%;
    margin: 0;
    background-color: #000;
  }
  .container {
    width: 100%;
    height: 100%;
    display: flex;
    cursor: none;
    justify-content: center;
    align-items: center;
  }

  .timer {
    color: #fff;
    text-align: center;
    font-family: TimerFont, 'Roboto Mono', monospace;
    font-weight: 100;
    font-size: 16em;
  }

  .breakmode {
    color: #fff8;
  }
</style>
<script type="text/javascript">
const helpText = `For help press '?' key or F1

Start/Pause	Primary (left) click		<Space> key
Reset		Secondary (right) click	<Backspace> key
Skip		Secondary (right) click	<Escape> key

Press F11 to toggle Fullscreen mode


Configuration
=============
Before continuing, add a '?' at the end of the URL, so that it now looks like this -
	${document.location.origin}${document.location.pathname}?

Work duration
-------------
Add the following text at the end of the URL and replace 25 with your choice of minutes -
	&work=25

Break duration
-------------
Add the following text at the end of the URL and replace 5 with your choice of minutes -
	&work=5

Auto-start
----------
If you want the work timer to start automatically, then add the following text -
	&autostart=true

Auto-break
----------
If you want the break timer to start automatically, then add the following text -
	&autobreak=true

Keep in mind that the value of &autobreak is set to that of &autostart by default. So, if you have set &autostart=true, it automatically implies &autobreak=true. In that case, if you want to disable auto-break, you need the set the following -
 	&autobreak=false

NOTE: The case of "true" and "false" is important. It should match exactly. Anything else is ignored.

Help on two Enters
------------------
By default, help is shown when Enter is pressed twice. To disable this, add the following to the URL -
	&enterhelp=false
`

function help() {
  alert(helpText);
}


function secondsToTime(secs) {
  var hours = Math.floor(secs / (60 * 60));
  hours = hours < 10 ? '0' + hours : hours;
  var divisor_for_minutes = secs % (60 * 60);
  var minutes = Math.floor(divisor_for_minutes / 60);
  // minutes = minutes < 10 ? '0' + minutes : minutes;
  var divisor_for_seconds = divisor_for_minutes % 60;
  var seconds = Math.ceil(divisor_for_seconds);
  seconds = seconds < 10 ? '0' + seconds : seconds;
  return minutes + ':' + seconds;
}

// Parse args
for (const entry of new URLSearchParams(window.location.search).entries()){
    console.log(`${entry[0]}: ${entry[1]}`);
    try{ eval(`window.${entry[0]} = ${entry[1]}`); }
    catch { eval(`window.${entry[0]} = "${entry[1]}"`); }
}

// set defaults if unset
var duration_work = (typeof(window.work) == "number") ? window.work : 25;
var duration_break = (typeof(window.break) == "number") ? window.break : 5;
var auto_start = (typeof(window.autostart) == "boolean") ? window.autostart : false;
var auto_break = (typeof(window.autobreak) == "boolean") ? window.autobreak : auto_start;
var enter_help = (typeof(window.enterhelp) == "boolean") ? window.enterhelp : true;

// working variables
var session = 0;
var end_milliseconds = 0;
var running;
var mad_keypress = 0;
var enter_pressed_once = 0;

function update_timer() {
  var time_now = new Date().getTime()
  if (end_milliseconds == 0) {
    window.end_milliseconds = time_now + target_milliseconds;
  }
  var now_milliseconds = new Date().getTime()
  var diff_milliseconds = end_milliseconds - now_milliseconds;
  var diff_seconds = Math.floor(diff_milliseconds / 1000);
  if (diff_seconds > 0) {
    var new_time_text = secondsToTime(diff_seconds);
    document.getElementById("time").innerHTML = new_time_text;
    return 1000 - new Date().getMilliseconds();
  } else {
    document.getElementById("time").innerHTML = "00:00";
    window.session %= 2
    update_target_variables();
    update_timer_color();
    return 1000;
  }
}

function update_timer_color() {
  if (window.session) {
    document.getElementById("timer").classList.add("breakmode");
  } else {
    document.getElementById("timer").classList.remove("breakmode");
  };
}

function update_target_variables() {
  if (window.session) {
    window.target_minutes = window.duration_break;
  } else {
    window.target_minutes = window.duration_work;
  }
  window.target_seconds = window.target_minutes * 60;
  window.target_milliseconds = window.target_seconds * 1000;
}

function timer_start() {
  window.running = true;
  main_loop()
}
function timer_toggle_pause() {
  if (window.running) {
    window.running = false;
    window.target_milliseconds = window.end_milliseconds - new Date().getTime();
    window.end_milliseconds = 0;
  } else {
    timer_start();
  }
}
function timer_reset() {
  window.running = false;
  update_target_variables();
  document.getElementById("time").innerHTML = secondsToTime(window.target_seconds);
  window.end_milliseconds = 0;
}
function timer_skip() {
  window.session++;
  window.session %= 2;
  var wasRunning = window.running
  timer_reset();
  update_timer_color();
  if (wasRunning && (window.session && window.auto_break || window.auto_start))
      timer_start()
}

function main_loop() {
  if (window.running) {
    setTimeout(main_loop, update_timer());
  }
}

function init() {
  update_target_variables();
  document.getElementById("time").innerHTML = secondsToTime(target_seconds);
  if (window.auto_start) {
    timer_start();
  };
}

function mouse_handler(event) {
  switch (event.button) {
    case 0: // primary (left for lefties) button
      timer_toggle_pause();
      break;
    case 2: // secondary (right for lefties) button
      timer_reset();
      break;
    case 1: // auxillary (middle) button
      timer_skip();
      break;
  }
}

function keydown_handler(event) {
  switch (event.key) {
    case " ":
      timer_toggle_pause();
      break;
    case "Backspace":
      timer_reset();
      break;
    case "Escape":
      timer_skip();
      break;
    // case "Enter":
    //   if (document.fullscreenElement != null) { document.exitFullscreen();}
    //   else { if (document.fullscreenEnabled) { document.documentElement.requestFullscreen();}; };
    //   break;
    case "Enter":
      window.enter_pressed_once++;
      window.enter_pressed_once %= 2;
      if (window.enter_pressed_once) { break; };
      if (!enter_help) { break; }
    case "?":
    case "F1":
      help();
      break
  }
}

function keypress_handler(event) {
  if (event.key == "Enter") { return; }; // handled by enter_pressed_once
  if (["?"," "].includes(event.key)) { window.mad_keypress = 0 }
  else {
    if (window.mad_keypress) {
      window.onkeypress = null; // i.e. mad help is only shown once
      help();
    };
    window.mad_keypress++;
  };
};

window.onload = init;
window.onmousedown = mouse_handler;
window.onkeydown = keydown_handler;
window.onkeypress = keypress_handler;
document.oncontextmenu = function() {return false;} // disable right click context menu
</script>

</head>
<body>
  <div class="container">
    <div class="timer" id="timer">
        <span id="time"></span>
    </div>
  </div>
</body>
</html>

<!--
  vim: et ts=2
-->
